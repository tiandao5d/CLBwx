{"id":13,"items":[{"id":13,"title":"命令模式","icon":"","description":"读曾探前辈【JavaScript设计模式与开发实践】有感","content":"<pre class=\"ql-syntax\" spellcheck=\"false\">    <span class=\"hljs-comment\">// 书中源码</span>\n    <span class=\"hljs-keyword\">var</span> Ryu = {\n      <span class=\"hljs-attr\">attack</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'攻击'</span>);\n      },\n      <span class=\"hljs-attr\">defense</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'防御'</span>);\n      },\n      <span class=\"hljs-attr\">jump</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'跳跃'</span>);\n      },\n      <span class=\"hljs-attr\">crouch</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'蹲下'</span>);\n      }\n    };\n    <span class=\"hljs-keyword\">var</span> makeCommand = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">receiver, state</span>) </span>{ <span class=\"hljs-comment\">// 创建命令</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n        receiver[state]();\n      }\n    };\n    <span class=\"hljs-keyword\">var</span> commands = {\n      <span class=\"hljs-string\">\"119\"</span>: <span class=\"hljs-string\">\"jump\"</span>, <span class=\"hljs-comment\">// W</span>\n      <span class=\"hljs-string\">\"115\"</span>: <span class=\"hljs-string\">\"crouch\"</span>, <span class=\"hljs-comment\">// S</span>\n      <span class=\"hljs-string\">\"97\"</span>: <span class=\"hljs-string\">\"defense\"</span>, <span class=\"hljs-comment\">// A</span>\n      <span class=\"hljs-string\">\"100\"</span>: <span class=\"hljs-string\">\"attack\"</span> <span class=\"hljs-comment\">// D</span>\n    };\n    <span class=\"hljs-keyword\">var</span> commandStack = []; <span class=\"hljs-comment\">// 保存命令的堆栈</span>\n    <span class=\"hljs-built_in\">document</span>.onkeypress = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ev</span>) </span>{\n      <span class=\"hljs-keyword\">var</span> keyCode = ev.keyCode,\n        command = makeCommand(Ryu, commands[keyCode]);\n      <span class=\"hljs-keyword\">if</span> (command) {\n        command(); <span class=\"hljs-comment\">// 执行命令</span>\n        commandStack.push(command); <span class=\"hljs-comment\">// 将刚刚执行过的命令保存进堆栈</span>\n      }\n    };\n    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'replay'</span>).onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{ <span class=\"hljs-comment\">// 点击播放录像</span>\n      <span class=\"hljs-keyword\">var</span> command;\n      <span class=\"hljs-keyword\">while</span> (command = commandStack.shift()) { <span class=\"hljs-comment\">// 从堆栈里依次取出命令并执行</span>\n        command();\n      }\n    };\n\n\n    <span class=\"hljs-comment\">// 以下为个人想法</span>\n\n    <span class=\"hljs-comment\">// 不在是创建命令，而是直接执行</span>\n    makeCommand = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">receiver, state</span>) </span>{ <span class=\"hljs-comment\">// 执行命令</span>\n      receiver[state]();\n    };\n    <span class=\"hljs-built_in\">document</span>.onkeypress = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">ev</span>) </span>{\n      <span class=\"hljs-keyword\">var</span> keyCode = ev.keyCode;\n      <span class=\"hljs-keyword\">if</span> (commands[keyCode]) { <span class=\"hljs-comment\">// 当按键无效时，减少了命令创建这一步</span>\n        <span class=\"hljs-comment\">// 不保存命令，而是保存参数，保存参数后，</span>\n        <span class=\"hljs-comment\">// 那后面执行时，如果源命令函数发生变化，也可以得到最新命令</span>\n        <span class=\"hljs-comment\">// 同时，还可以给命令增加和修改参数</span>\n        <span class=\"hljs-keyword\">var</span> args = [Ryu, commands[keyCode]];\n        makeCommand(...args); <span class=\"hljs-comment\">// 执行命令</span>\n        commandStack.push(args); <span class=\"hljs-comment\">// 保存参数</span>\n      }\n    };\n    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'replay'</span>).onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{ <span class=\"hljs-comment\">// 点击播放录像</span>\n      <span class=\"hljs-keyword\">var</span> args;\n      <span class=\"hljs-keyword\">while</span> (args = commandStack.shift()) { <span class=\"hljs-comment\">// 从堆栈里依次取出命令参数并执行</span>\n        makeCommand(...args);\n      }\n    };\n</pre>","type":"javascript","createTime":1605850265031,"updateTime":1606377057645},{"id":12,"title":"缓存机制","icon":"","description":"早先主要是为了缓存请求数据，也是为了防止以前旧项目中的经常出现多次同样请求的情况写的","content":"<p>以前旧项目中各组件确实需要请求同一个接口，参数有时相同有时不同</p><p><br></p><p>写了这个缓存且是异步执行的方法</p><p><br></p><p>异步执行参考了vue的异步更新，也有些计算属性的调调</p><p><br></p><p>理念同样可以用于普通函数的缓存计算结果</p><p><br></p><p>也给了简单的缓存自动清理机制</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-comment\">// 异步函数执行缓存</span>\n<span class=\"hljs-comment\">// fn 一个promise的异步函数，会将返回值缓存</span>\n<span class=\"hljs-comment\">// 同时多次请求时，会等待第一次的返回结果之后在执行列队请求</span>\n<span class=\"hljs-comment\">// 有点vue计算属性的调调，也参考了vue的异步更新机制</span>\n<span class=\"hljs-keyword\">interface</span> SCItem {\n  <span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// 关键key值，判断是否可以使用缓存</span>\n  args: <span class=\"hljs-built_in\">any</span>; <span class=\"hljs-comment\">// 函数形参</span>\n  res: <span class=\"hljs-built_in\">any</span>; <span class=\"hljs-comment\">// 记录正确返回</span>\n  ts: <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// 记录时间戳</span>\n  err: <span class=\"hljs-built_in\">any</span>; <span class=\"hljs-comment\">// 记录错误返回</span>\n  cbs: <span class=\"hljs-built_in\">any</span>[]; <span class=\"hljs-comment\">// 记录回调队列</span>\n}\n<span class=\"hljs-keyword\">const</span> syncCache = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n  <span class=\"hljs-keyword\">let</span> tt = <span class=\"hljs-number\">10</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>; <span class=\"hljs-comment\">// 默认时间</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">clearCache</span>(<span class=\"hljs-params\">time: <span class=\"hljs-built_in\">number</span>, fn: <span class=\"hljs-built_in\">Function</span></span>) </span>{\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n      fn();\n      clearCache(time, fn);\n    }, time);\n  }\n  <span class=\"hljs-comment\">// cacheTime 缓存时间</span>\n  <span class=\"hljs-comment\">// clearTime 缓存清除间隔时间</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">syncCache</span>(<span class=\"hljs-params\">fn: <span class=\"hljs-built_in\">Function</span>, cacheTime?: <span class=\"hljs-built_in\">number</span>, clearTime = tt</span>) </span>{\n    <span class=\"hljs-comment\">// 列队等待的数据</span>\n    <span class=\"hljs-keyword\">let</span> cacheData = {};\n    <span class=\"hljs-keyword\">let</span> args = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>, <span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-keyword\">let</span> that = <span class=\"hljs-built_in\">this</span>;\n    <span class=\"hljs-comment\">// 缓存时间毫秒数，超过这个时间会重新请求</span>\n    cacheTime = cacheTime &gt; <span class=\"hljs-number\">0</span> ? cacheTime : tt;\n    <span class=\"hljs-comment\">// 简单的垃圾清除机制</span>\n    <span class=\"hljs-comment\">// 一定的时间内清空缓存</span>\n    <span class=\"hljs-keyword\">if</span> (clearTime &gt; <span class=\"hljs-number\">0</span>) {\n      clearCache(clearTime, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n        cacheData = {};\n      });\n    }\n\n\n    <span class=\"hljs-comment\">// 以key为唯一值，加入缓存列队，args为fn的执行参数</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addCacheQueue</span>(<span class=\"hljs-params\">key: <span class=\"hljs-built_in\">string</span>, args: <span class=\"hljs-built_in\">any</span></span>) </span>{\n      <span class=\"hljs-keyword\">let</span> item: SCItem = cacheData[key];\n      <span class=\"hljs-keyword\">let</span> curTime = +<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();\n      <span class=\"hljs-comment\">// 已经执行过异步函数，得到异步返回值了，在缓存时间内，所以直接返回内容</span>\n      <span class=\"hljs-keyword\">if</span> (item) {\n        <span class=\"hljs-keyword\">if</span> (item.res) {\n          <span class=\"hljs-keyword\">if</span> (curTime - item.ts &lt; cacheTime) {\n            <span class=\"hljs-comment\">// 如果经常使用，则继续缓存，重置上次缓存时间</span>\n            <span class=\"hljs-comment\">//  称之为频率缓存</span>\n            item.ts = curTime;\n            <span class=\"hljs-comment\">// 拷贝返回</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.resolve(copy(item.res));\n          } <span class=\"hljs-keyword\">else</span> {\n            item = <span class=\"hljs-literal\">null</span>;\n          }\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (item.err) {\n          item = <span class=\"hljs-literal\">null</span>;\n        }\n      }\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n        <span class=\"hljs-comment\">// 已经执行了异步函数，但是没有返回，记录列队</span>\n        <span class=\"hljs-keyword\">if</span> (item) {\n          item.cbs.push(resolve);\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-comment\">// 执行异步函数</span>\n          item = {\n            key,\n            args,\n            <span class=\"hljs-attr\">ts</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 记录时间戳</span>\n            <span class=\"hljs-attr\">res</span>: <span class=\"hljs-literal\">null</span>, <span class=\"hljs-comment\">// 记录正确返回</span>\n            <span class=\"hljs-attr\">err</span>: <span class=\"hljs-literal\">null</span>, <span class=\"hljs-comment\">// 记录错误返回</span>\n            <span class=\"hljs-attr\">cbs</span>: [resolve],\n          };\n          <span class=\"hljs-comment\">// 加入列队数据，向前添加</span>\n          cacheData[key] = item;\n          tryFn(item);\n        }\n      });\n    }\n\n\n    <span class=\"hljs-comment\">// 执行函数</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">tryFn</span>(<span class=\"hljs-params\">item: SCItem</span>) </span>{\n      <span class=\"hljs-keyword\">return</span> fn\n        .apply(that, item.args)\n        .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> {\n          item.res = res;\n          <span class=\"hljs-comment\">// 请求成功后开始记录缓存时间</span>\n          item.ts = +<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();\n          <span class=\"hljs-keyword\">return</span> res;\n        })\n        .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">err: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> {\n          item.err = err;\n          <span class=\"hljs-keyword\">return</span> err;\n        })\n        .finally(<span class=\"hljs-function\">() =&gt;</span> {\n          <span class=\"hljs-comment\">// 执行列队回调</span>\n          <span class=\"hljs-comment\">// 拷贝返回</span>\n          item.cbs.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">cb: (arg0: <span class=\"hljs-built_in\">any</span>, arg1: <span class=\"hljs-built_in\">any</span>) =&gt; <span class=\"hljs-built_in\">any</span></span>) =&gt;</span>\n            cb(copy(item.res), item.err)\n          );\n          <span class=\"hljs-comment\">// 置空列队回调</span>\n          item.cbs = [];\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        });\n    }\n\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...newArgs</span>) </span>{\n      <span class=\"hljs-comment\">// 可以为缓存的唯一值</span>\n      <span class=\"hljs-keyword\">let</span> key = newArgs.pop();\n      newArgs = args.concat(newArgs);\n      <span class=\"hljs-comment\">// 判断key有效，也就是函数的最后一个参数是可以用来当成key的，自定义key</span>\n      <span class=\"hljs-comment\">// 无效的话直接将参数转成字符串作为key</span>\n      <span class=\"hljs-keyword\">if</span> (!(key &amp;&amp; <span class=\"hljs-keyword\">typeof</span> key === <span class=\"hljs-string\">\"string\"</span> &amp;&amp; key.startsWith(<span class=\"hljs-string\">\"_XLKEY\"</span>))) {\n        newArgs.push(key);\n        key = <span class=\"hljs-built_in\">JSON</span>.stringify(newArgs); <span class=\"hljs-comment\">// 参数为key值，用于缓存的key</span>\n      }\n      <span class=\"hljs-keyword\">return</span> addCacheQueue(key, newArgs);\n    };\n  };\n})();\n</pre>","type":"javascript","createTime":1605844007790,"updateTime":1606377050896},{"id":11,"title":"深层的对象合并，数据补全","icon":"","description":"针对后台数据一些字段有时存在有时不存在，算是一个深层的Object.assign方法，主要用途是数据补全","content":"<p>也是旧项目中，后台数据不全，字段有时存在有时不存在，导致后续要多很多判断</p><p><br></p><p>所以写了这个方法</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-comment\">// 此方法为深层次的对象合并，但不考虑深拷贝，只考虑对象 [object, Object]，</span>\n<span class=\"hljs-comment\">// 不考虑数组，函数，时间等引用类型，一个深层次的 Object.assign方法</span>\n<span class=\"hljs-comment\">// 主要用途是数据补全，给一个默认格式，然后可以默认补全后面的数据</span>\n<span class=\"hljs-comment\">// 保证数据的完整性</span>\n<span class=\"hljs-keyword\">const</span> assignObj = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">assignObj</span>() </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\">obj1, obj2</span>) </span>{\n    <span class=\"hljs-keyword\">for</span> (let k in obj2) {\n      let val1 = obj1[k];\n      let val2 = obj2[k];\n      <span class=\"hljs-keyword\">if</span> (isObject(val1) &amp;&amp; isObject(val2)) {\n        obj1[k] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span>(<span class=\"hljs-params\">val1, val2</span>)</span>;\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isObject(val2)) {\n        <span class=\"hljs-comment\">// 此时不能直接赋值，否则obj2的值可能会被改变</span>\n        <span class=\"hljs-comment\">// 因为直接赋值了一个引用类型，下次循环时可能会改变这个引用类型</span>\n        <span class=\"hljs-comment\">// 进行直接拷贝然后再赋值相当于拷贝了一份引用类型的基础结构</span>\n        <span class=\"hljs-comment\">// 而不是直接使用后面的引用类型，无需精准的拷贝，因为只需要基础结构即可</span>\n        val1 = JSON.parse(JSON.stringify(val2));\n        obj1[k] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span>(<span class=\"hljs-params\">val1, val2</span>)</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        obj1[k] = val2;\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> obj1;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item1, ...args</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (!(args.length &gt; <span class=\"hljs-number\">0</span>)) {\n      <span class=\"hljs-keyword\">return</span> item1;\n    }\n    <span class=\"hljs-keyword\">return</span> args.reduce((total, item) =&gt; {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span>(<span class=\"hljs-params\">total, item</span>)</span>;\n    }, item1);\n  };\n})();\n</pre>","type":"javascript","createTime":1605843126390,"updateTime":1606377026269},{"id":10,"title":"简单的提示工具","icon":"","description":"这是原先一个旧项目中各种提示工具整的我烦死了，才想了写一个简单提示工具玩一玩，配合animate.css一起各种动效，有点意思","content":"<p><a href=\"https://tiandao5d.github.io/xlToast/\" rel=\"noopener noreferrer\" target=\"_blank\">示例</a></p><p><br></p><p><a href=\"https://github.com/tiandao5d/xlToast\" rel=\"noopener noreferrer\" target=\"_blank\">源码</a></p>","type":"javascript","createTime":1605842873120,"updateTime":1606377020995},{"id":9,"title":"发布订阅模式","icon":"","description":"自写的发布订阅模式，和市面上的差别在于，写了一个只响应最后一次监听的回调函数","content":"<p>自写的发布订阅模式，和市面上的差别在于，写了一个只响应最后一次监听的回调函数</p><p><br></p><p>也是以前一个旧项目中的为了减少重复监听问题</p><p><br></p><p>一种偷懒的方法，如果不知何种时机（或者是根本不想管）清除监听副作用时，配合代理模式一起，当年玩的是不要太爽</p><p><br></p><p>那时typescript使用不熟，欢迎批评教育</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-comment\">// eventType 事件名称， eventKey 事件名称空间， eventFn 事件绑定的函数，</span>\n<span class=\"hljs-comment\">// mode 事件绑定的模式, on 正常监听 once 只执行一次的监听</span>\n<span class=\"hljs-comment\">// mode ronce 只能绑定一个函数的监听， eventKey下数组只能有一个绑定函数后面的会覆盖前面的</span>\n<span class=\"hljs-comment\">// data结构 {eventType: {eventKey: [ { eventFn, mode } ]}}</span>\n<span class=\"hljs-comment\">/**\n * let xlEventCls = new XLEvents();\n * // 一下a为事件名称，b为命名空间\n * // 会触发a事件名称下的所有命名空间\n * xlEventCls.emit('a', 1, 2);\n * // 支付触发a事件名下的b命名空间\n * xlEventCls.emit('a.b', 1, 2);\n * // 普通监听，执行一次会多出一个函数监听\n * xlEventCls.on('a.b',()=&gt;{});\n * xlEventCls.on('a.b',()=&gt;{}, 'on');\n * // 只会触发一次的监听，触发一次后会删除监听\n * // 同一事件名称中的同一个命名空间可以有多个once的类型\n * xlEventCls.once('a.b',()=&gt;{});\n * xlEventCls.on('a.b',()=&gt;{}, 'once');\n * // 防止重复监听\n * // 和普通的差不多，只是在同一个事件名称下的同一个命名空间只会触发最后一次的监听函数\n * // 为了防止重复监听带来的副作用\n * xlEventCls.ronce('a.b',()=&gt;{});\n * xlEventCls.on('a.b',()=&gt;{}, 'ronce');\n * // 监听时也可以不加命名空间，会默认给命名空间 $xl_default_ll，事件名称也是一样默认 $xl_default_ll\n * // 所以请不要给出和 $xl_default_ll 一样的命名，否则可能会出现BUG\n */</span>\n<span class=\"hljs-keyword\">type</span> Mode = <span class=\"hljs-string\">\"on\"</span> | <span class=\"hljs-string\">\"once\"</span> | <span class=\"hljs-string\">\"ronce\"</span>;\n<span class=\"hljs-keyword\">interface</span> XLEItem {\n  <span class=\"hljs-attr\">eventFn</span>: <span class=\"hljs-built_in\">Function</span>;\n  mode: Mode;\n}\n<span class=\"hljs-keyword\">interface</span> XLEData {\n  [eventType: <span class=\"hljs-built_in\">string</span>]: {\n    [eventKey: <span class=\"hljs-built_in\">string</span>]: XLEItem[];\n  };\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">XLEvents</span> </span>{\n  <span class=\"hljs-attr\">data</span>: XLEData;\n  modeArr: <span class=\"hljs-built_in\">string</span>[];\n  dkey: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>()</span> {\n    <span class=\"hljs-comment\">// 数据函数存储</span>\n    <span class=\"hljs-built_in\">this</span>.data = {};\n    <span class=\"hljs-comment\">// 可用的事件监听模式</span>\n    <span class=\"hljs-built_in\">this</span>.modeArr = [<span class=\"hljs-string\">\"on\"</span>, <span class=\"hljs-string\">\"once\"</span>, <span class=\"hljs-string\">\"ronce\"</span>];\n    <span class=\"hljs-comment\">// 如果碰巧名称一样，那抱歉了，bug</span>\n    <span class=\"hljs-built_in\">this</span>.dkey = <span class=\"hljs-string\">\"$xl_default_ll\"</span>;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">formatType</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">string</span>, isd?: <span class=\"hljs-built_in\">boolean</span></span>)</span> {\n    <span class=\"hljs-keyword\">let</span> arr = <span class=\"hljs-keyword\">type</span>.split(<span class=\"hljs-string\">\".\"</span>);\n    <span class=\"hljs-keyword\">let</span> eventType = arr[<span class=\"hljs-number\">0</span>] || <span class=\"hljs-built_in\">this</span>.dkey; <span class=\"hljs-comment\">// 事件名称</span>\n    <span class=\"hljs-keyword\">let</span> eventKey = arr[<span class=\"hljs-number\">1</span>] ? arr[<span class=\"hljs-number\">1</span>] : isd ? <span class=\"hljs-built_in\">this</span>.dkey : <span class=\"hljs-string\">''</span>; <span class=\"hljs-comment\">// 事件命名空间</span>\n  \n    <span class=\"hljs-comment\">// 事件属性下的所有命名空间对象，是个对象</span>\n    <span class=\"hljs-keyword\">let</span> tItem = <span class=\"hljs-built_in\">this</span>.data[eventType] ? { ...this.data[eventType] } : {};\n    <span class=\"hljs-comment\">// 单个命名空间对象数据，是个数组XLEItem[]</span>\n    <span class=\"hljs-keyword\">let</span> kItem = tItem[eventKey] ? [...tItem[eventKey]] : [];\n    <span class=\"hljs-keyword\">return</span> { eventType, eventKey, tItem, kItem };\n  }\n  <span class=\"hljs-comment\">// 监听时如果没有事件名称或命名空间，都会给默认值</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">on</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">any</span>, eventFn: <span class=\"hljs-built_in\">Function</span>, mode: Mode = <span class=\"hljs-string\">\"on\"</span></span>)</span> {\n    <span class=\"hljs-keyword\">let</span> { eventType, eventKey, tItem, kItem } = <span class=\"hljs-built_in\">this</span>.formatType(<span class=\"hljs-keyword\">type</span>, <span class=\"hljs-literal\">true</span>);\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.modeArr.includes(mode)) {\n      mode = <span class=\"hljs-string\">\"on\"</span>;\n    }\n    <span class=\"hljs-keyword\">if</span> (\n      <span class=\"hljs-keyword\">typeof</span> eventFn === <span class=\"hljs-string\">\"function\"</span> &amp;&amp;\n      !kItem.some(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item.eventFn === eventFn)\n    ) {\n      <span class=\"hljs-keyword\">let</span> eItem: XLEItem = { eventFn, mode };\n      <span class=\"hljs-comment\">// 只会监听一个函数，后面的函数监听会覆盖前面的</span>\n      <span class=\"hljs-comment\">// 同一个命名空间只能有一个 'ronce' 的属性</span>\n      <span class=\"hljs-comment\">// 但是可以同时存在多个其他类型的监听</span>\n      <span class=\"hljs-keyword\">if</span> (mode === <span class=\"hljs-string\">\"ronce\"</span>) {\n        kItem = kItem.filter(<span class=\"hljs-function\">(<span class=\"hljs-params\">o</span>) =&gt;</span> o.mode !== <span class=\"hljs-string\">\"ronce\"</span>);\n      }\n      kItem.push(eItem);\n    }\n    tItem[eventKey] = kItem;\n    <span class=\"hljs-built_in\">this</span>.data[eventType] = tItem;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>;\n  }\n  <span class=\"hljs-comment\">// 如果type值相同的话，只会响应最后一次的回调函数</span>\n  <span class=\"hljs-comment\">// 一种减少副作用的方法，防止多次重复监听</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">ronce</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">any</span>, eventFn: <span class=\"hljs-built_in\">any</span></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.on(<span class=\"hljs-keyword\">type</span>, eventFn, <span class=\"hljs-string\">\"ronce\"</span>);\n  }\n  <span class=\"hljs-comment\">// 只执行一次，没啥不同的</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">once</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">any</span>, eventFn: <span class=\"hljs-built_in\">any</span></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.on(<span class=\"hljs-keyword\">type</span>, eventFn, <span class=\"hljs-string\">\"once\"</span>);\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">emitKItem</span>(<span class=\"hljs-params\">kItem: <span class=\"hljs-built_in\">any</span>[], args: <span class=\"hljs-built_in\">any</span>[]</span>)</span> {\n    kItem = kItem.filter(<span class=\"hljs-function\">(<span class=\"hljs-params\">eItem: { eventFn: <span class=\"hljs-built_in\">any</span>; mode: <span class=\"hljs-built_in\">string</span> }</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">let</span> fn = eItem.eventFn;\n      <span class=\"hljs-keyword\">try</span> {\n        fn(...args);\n      } <span class=\"hljs-keyword\">catch</span> (error) {\n        <span class=\"hljs-built_in\">console</span>.log(error);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n      }\n      <span class=\"hljs-comment\">// 只监听一次的，之后会直接删除</span>\n      <span class=\"hljs-keyword\">if</span> (eItem.mode === <span class=\"hljs-string\">\"once\"</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n      }\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    });\n    <span class=\"hljs-keyword\">return</span> kItem;\n  }\n\n\n  <span class=\"hljs-comment\">// 触发时，如果没有命名空间</span>\n  <span class=\"hljs-comment\">// 会触发此事件下所有的事件绑定</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">emit</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">any</span>, ...args: <span class=\"hljs-built_in\">any</span>[]</span>)</span> {\n    <span class=\"hljs-keyword\">let</span> { eventType, eventKey, tItem, kItem } = <span class=\"hljs-built_in\">this</span>.formatType(<span class=\"hljs-keyword\">type</span>);\n    <span class=\"hljs-comment\">// 触发此事件下所有的事件绑定</span>\n    <span class=\"hljs-keyword\">if</span> (!eventKey) {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> k <span class=\"hljs-keyword\">in</span> tItem) {\n        <span class=\"hljs-keyword\">if</span> (tItem[k] &amp;&amp; tItem[k].length) {\n          tItem[k] = <span class=\"hljs-built_in\">this</span>.emitKItem(tItem[k], args);\n        }\n      }\n      <span class=\"hljs-built_in\">this</span>.data[eventType] = tItem;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>;\n    }\n    <span class=\"hljs-keyword\">if</span> (kItem &amp;&amp; kItem.length) {\n      kItem = <span class=\"hljs-built_in\">this</span>.emitKItem(kItem, args);\n      tItem[eventKey] = kItem;\n      <span class=\"hljs-built_in\">this</span>.data[eventType] = tItem;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>;\n  }\n\n\n  <span class=\"hljs-comment\">// 解除绑定时， 如果没有命名空间</span>\n  <span class=\"hljs-comment\">// 则清空此事件下所有的监听</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">off</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">any</span>, eventFn?: <span class=\"hljs-built_in\">Function</span></span>)</span> {\n    <span class=\"hljs-keyword\">let</span> { eventType, eventKey, tItem, kItem } = <span class=\"hljs-built_in\">this</span>.formatType(<span class=\"hljs-keyword\">type</span>);\n    <span class=\"hljs-comment\">// 清空此事件下所有的事件绑定</span>\n    <span class=\"hljs-keyword\">if</span> (!eventKey) {\n      <span class=\"hljs-built_in\">this</span>.data[eventType] = {};\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>;\n    }\n    <span class=\"hljs-keyword\">if</span> (kItem &amp;&amp; kItem.length) {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> eventFn === <span class=\"hljs-string\">\"function\"</span>) {\n        <span class=\"hljs-comment\">// 删掉单个监听</span>\n        kItem = kItem.filter(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item.eventFn !== eventFn);\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 删除整个组的</span>\n        kItem = [];\n      }\n      tItem[eventKey] = kItem;\n      <span class=\"hljs-built_in\">this</span>.data[eventType] = tItem;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>;\n  }\n}\n</pre>","type":"javascript","createTime":1605842245152,"updateTime":1606377004904},{"id":8,"title":"列表选择类","icon":"","description":"公司项目中，很多需要做列表的展现和选择点击的，所以封装了这个类","content":"<p>公司项目中，很多需要做列表的展现和选择点击的，所以封装了这个类</p><p><br></p><p>方便列表处理，增删改查，选中，最多最少选中等功能</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ListMultiple</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(options = {}) {\n      <span class=\"hljs-keyword\">this</span>.min = options.min || <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-keyword\">this</span>.max = options.max || <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.min &gt; <span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-keyword\">this</span>.max &gt; <span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-keyword\">this</span>.max &lt; <span class=\"hljs-keyword\">this</span>.min) {\n        <span class=\"hljs-keyword\">this</span>.min = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">this</span>.max = <span class=\"hljs-number\">0</span>;\n        console.log(<span class=\"hljs-string\">\"参数错误，min 不能大于 max\"</span>);\n      }\n      <span class=\"hljs-keyword\">this</span>.dOptions = { ...options };\n      <span class=\"hljs-keyword\">this</span>.resetItems({}, { type: <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$_lm_init</span>\"</span> });\n    }\n\n\n    <span class=\"hljs-comment\">// 重置项目数据</span>\n    resetItems(options = {}, eventData) {\n      options = { ...<span class=\"hljs-keyword\">this</span>.dOptions, ...options };\n      <span class=\"hljs-keyword\">this</span>.dOptions = options;\n      let selectInOri =\n        typeof options.selectInOri === <span class=\"hljs-string\">\"boolean\"</span>\n          ? options.selectInOri\n          : typeof <span class=\"hljs-keyword\">this</span>.selectInOri === <span class=\"hljs-string\">\"boolean\"</span>\n          ? <span class=\"hljs-keyword\">this</span>.selectInOri\n          : <span class=\"hljs-literal\">false</span>;\n      let oriItems = options.oriItems || <span class=\"hljs-keyword\">this</span>.oriItems || [];\n      let selectItems = options.selectItems || <span class=\"hljs-keyword\">this</span>.selectItems || [];\n      let k =\n        options.k || <span class=\"hljs-keyword\">this</span>.k || (oriItems[<span class=\"hljs-number\">0</span>] &amp;&amp; oriItems[<span class=\"hljs-number\">0</span>].id ? <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-string\">\"\"</span>);\n\n\n      <span class=\"hljs-comment\">// 有从属关系，selectItems 的数据必须存在于 oriItems中</span>\n      <span class=\"hljs-keyword\">if</span> (selectInOri) {\n        selectItems = <span class=\"hljs-keyword\">this</span>.filterEvery12(selectItems, oriItems);\n      }\n      <span class=\"hljs-comment\">// oriItems - selectItems = listItems</span>\n      let listItems = <span class=\"hljs-keyword\">this</span>.filterSome1(oriItems, selectItems);\n      <span class=\"hljs-keyword\">if</span> (!(eventData &amp;&amp; eventData.type === <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$_lm_init</span>\"</span>)) {\n        <span class=\"hljs-comment\">// 选中数据不能少于</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.min &gt; <span class=\"hljs-number\">0</span>) {\n          <span class=\"hljs-keyword\">if</span> (selectItems.length &lt; <span class=\"hljs-keyword\">this</span>.min) {\n            <span class=\"hljs-keyword\">this</span>.onError(<span class=\"hljs-string\">\"min_err\"</span>, {\n              txt: `选中的数据量不能小于给定的 min: ${<span class=\"hljs-keyword\">this</span>.min}`,\n              items: [...selectItems],\n            });\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n          }\n        }\n\n\n        <span class=\"hljs-comment\">// 选中数据不能大于</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.max &gt; <span class=\"hljs-number\">0</span>) {\n          <span class=\"hljs-keyword\">if</span> (selectItems.length &gt; <span class=\"hljs-keyword\">this</span>.max) {\n            <span class=\"hljs-keyword\">this</span>.onError(<span class=\"hljs-string\">\"max_err\"</span>, {\n              txt: `选中的数据量不能小于给定的 max: ${<span class=\"hljs-keyword\">this</span>.max}`,\n              items: [...selectItems],\n            });\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n          }\n        }\n      }\n\n\n      <span class=\"hljs-comment\">// 原始列表数据</span>\n      <span class=\"hljs-keyword\">this</span>.oriItems = [...oriItems];\n      <span class=\"hljs-comment\">// 选中列表数据</span>\n      <span class=\"hljs-keyword\">this</span>.selectItems = [...selectItems];\n      <span class=\"hljs-comment\">// 原始 - 选中</span>\n      <span class=\"hljs-keyword\">this</span>.listItems = [...listItems];\n      <span class=\"hljs-comment\">// 对比两个列表项目相等的 key 值</span>\n      <span class=\"hljs-keyword\">this</span>.k = k;\n      <span class=\"hljs-comment\">// 是否有从属关系，selectItems中元素 是否必须是存在于 oriItems中</span>\n      <span class=\"hljs-keyword\">this</span>.selectInOri = selectInOri;\n      <span class=\"hljs-keyword\">if</span> (eventData &amp;&amp; eventData.type !== <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$_lm_init</span>\"</span>) {\n        eventData.target = <span class=\"hljs-keyword\">this</span>;\n        <span class=\"hljs-keyword\">this</span>.emitChange(eventData.type, eventData);\n      }\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n    }\n    <span class=\"hljs-comment\">// 差集，1有，2没有</span>\n    filterSome1(items1, items2, k = <span class=\"hljs-keyword\">this</span>.k) {\n      <span class=\"hljs-keyword\">if</span> (k) {\n        <span class=\"hljs-keyword\">return</span> items1.filter((o) =&gt; !items2.some((oo) =&gt; o[k] === oo[k]));\n      }\n      <span class=\"hljs-keyword\">return</span> items1.filter((o) =&gt; !items2.some((oo) =&gt; o === oo));\n    }\n    <span class=\"hljs-comment\">// 交集，1和2同时拥有</span>\n    filterEvery12(items1, items2, k = <span class=\"hljs-keyword\">this</span>.k) {\n      <span class=\"hljs-keyword\">if</span> (k) {\n        <span class=\"hljs-keyword\">return</span> items1.filter((o) =&gt; items2.some((oo) =&gt; o[k] === oo[k]));\n      }\n      <span class=\"hljs-keyword\">return</span> items1.filter((o) =&gt; items2.some((oo) =&gt; o === oo));\n    }\n    hasSelect(item, k = <span class=\"hljs-keyword\">this</span>.k) {\n      <span class=\"hljs-comment\">// 判断指定项目是否是选中的状态</span>\n      <span class=\"hljs-keyword\">if</span> (k) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.selectItems.some((o) =&gt; o[k] === item[k]);\n      }\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.selectItems.some((o) =&gt; o === item);\n    }\n    <span class=\"hljs-comment\">// 简单的数据转化，因为这里是对数组进行操作</span>\n    toArr(item) {\n      let items = <span class=\"hljs-literal\">null</span>;\n      <span class=\"hljs-keyword\">if</span> (item instanceof Array) {\n        items = item;\n      } <span class=\"hljs-keyword\">else</span> {\n        items = [item];\n      }\n      <span class=\"hljs-keyword\">return</span> items;\n    }\n    onError() {}\n    onChange() {}\n    emitChange() {\n      <span class=\"hljs-keyword\">this</span>.onChange(...arguments);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n    }\n    hasAll(k = <span class=\"hljs-keyword\">this</span>.k) {\n      <span class=\"hljs-comment\">// 判断是否全选</span>\n      <span class=\"hljs-keyword\">if</span> (k) {\n        <span class=\"hljs-keyword\">return</span> (\n          <span class=\"hljs-keyword\">this</span>.oriItems.length === <span class=\"hljs-keyword\">this</span>.selectItems.length &amp;&amp;\n          <span class=\"hljs-keyword\">this</span>.oriItems.every((o) =&gt;\n            <span class=\"hljs-keyword\">this</span>.selectItems.some((oo) =&gt; o[k] === oo[k])\n          )\n        );\n      }\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"hljs-keyword\">this</span>.oriItems.length === <span class=\"hljs-keyword\">this</span>.selectItems.length &amp;&amp;\n        <span class=\"hljs-keyword\">this</span>.oriItems.every((o) =&gt; <span class=\"hljs-keyword\">this</span>.selectItems.some((oo) =&gt; o === oo))\n      );\n    }\n    toggleAll() {\n      <span class=\"hljs-comment\">// 切换全选状态</span>\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.hasAll()) {\n        <span class=\"hljs-keyword\">this</span>.clearItems();\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">this</span>.allItems();\n      }\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n    }\n    allItems() {\n      <span class=\"hljs-comment\">// 全选数据</span>\n      <span class=\"hljs-keyword\">this</span>.resetItems(\n        {\n          selectItems: <span class=\"hljs-keyword\">this</span>.oriItems,\n          oriItems: <span class=\"hljs-keyword\">this</span>.oriItems,\n        },\n        {\n          type: <span class=\"hljs-string\">\"all\"</span>,\n        }\n      );\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n    }\n    clearItems() {\n      <span class=\"hljs-comment\">// 清空数据</span>\n      <span class=\"hljs-keyword\">this</span>.resetItems(\n        {\n          selectItems: [],\n        },\n        {\n          type: <span class=\"hljs-string\">\"clear\"</span>,\n        }\n      );\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n    }\n    onToggleItems(item) {\n      <span class=\"hljs-comment\">// 切换选中与不选中</span>\n      let items = <span class=\"hljs-keyword\">this</span>.toArr(item);\n      <span class=\"hljs-comment\">// 过滤出选中状态中没有的数据才有添加的意义</span>\n      let addItems = <span class=\"hljs-keyword\">this</span>.filterSome1(items, <span class=\"hljs-keyword\">this</span>.selectItems);\n      <span class=\"hljs-comment\">// 过滤出选中状态中有的数据，才有删除的意义</span>\n      let removeItems = <span class=\"hljs-keyword\">this</span>.filterEvery12(items, <span class=\"hljs-keyword\">this</span>.selectItems);\n      <span class=\"hljs-comment\">// 有需要添加的数据</span>\n      <span class=\"hljs-keyword\">if</span> (addItems.length) {\n        <span class=\"hljs-keyword\">this</span>.onSelectItems(addItems);\n      }\n      <span class=\"hljs-comment\">// 有需要删除的数据</span>\n      <span class=\"hljs-keyword\">if</span> (removeItems.length) {\n        <span class=\"hljs-keyword\">this</span>.onRemoveItems(removeItems);\n      }\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n    }\n    onSelectItems(item) {\n      let items = <span class=\"hljs-keyword\">this</span>.toArr(item); <span class=\"hljs-comment\">// 转数组</span>\n      <span class=\"hljs-comment\">// 过滤出选中状态中没有的数据才有添加的意义</span>\n      items = <span class=\"hljs-keyword\">this</span>.filterSome1(items, <span class=\"hljs-keyword\">this</span>.selectItems);\n      <span class=\"hljs-keyword\">if</span> (items.length) {\n        let selectItems = [...<span class=\"hljs-keyword\">this</span>.selectItems, ...items];\n        <span class=\"hljs-keyword\">this</span>.resetItems(\n          {\n            selectItems,\n          },\n          {\n            type: <span class=\"hljs-string\">\"select\"</span>,\n            items: [...items],\n          }\n        );\n      }\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n    }\n    onRemoveItems(item) {\n      let items = <span class=\"hljs-keyword\">this</span>.toArr(item);\n      <span class=\"hljs-comment\">// 过滤出选中状态中有的数据，才有删除的意义</span>\n      items = <span class=\"hljs-keyword\">this</span>.filterEvery12(items, <span class=\"hljs-keyword\">this</span>.selectItems);\n      <span class=\"hljs-keyword\">if</span> (items.length) {\n        let selectItems = <span class=\"hljs-keyword\">this</span>.filterSome1(<span class=\"hljs-keyword\">this</span>.selectItems, items);\n        <span class=\"hljs-keyword\">this</span>.resetItems(\n          {\n            selectItems,\n          },\n          {\n            type: <span class=\"hljs-string\">\"remove\"</span>,\n            items: [...items],\n          }\n        );\n      }\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n    }\n  }\n</pre>","type":"javascript","createTime":1605841541605,"updateTime":1606377870263},{"id":7,"title":"让 useReducer 可以使用惰性 state","icon":"","content":"<p>在使用useReducer 时，发现这个鬼记录的state没有惰性功能</p><p><br></p><p>如果我要记录的state的初始值需要经过大量计算得到，那就有点尴尬了</p><p><br></p><p>然后就想了个简单办法，借用useState的惰性功能</p><p><br></p><p>自定义hook代码如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useXLReducer</span>(<span class=\"hljs-params\">_state</span>) </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reducer</span>(<span class=\"hljs-params\">state, action</span>) </span>{\n    <span class=\"hljs-comment\">// ... 一些操作</span>\n    <span class=\"hljs-keyword\">return</span> { ...state};\n  }\n  <span class=\"hljs-comment\">// 这个是惰性的，如果_state是一个函数，会惰性执行</span>\n  <span class=\"hljs-comment\">// 这个状态只会被第一次用到，也是保存了初始值</span>\n  <span class=\"hljs-comment\">// 这样就可以让 useReducer 这个 hook 转为惰性的</span>\n  <span class=\"hljs-comment\">// 支持传入的_state是一个函数</span>\n  <span class=\"hljs-keyword\">const</span> [initState] = useState(_state);\n  <span class=\"hljs-keyword\">const</span> [state, dispatch] = useReducer(reducer, initState);\n\n\n  <span class=\"hljs-comment\">// 看个人喜好 可以将初始值 initState 保存下来</span>\n  <span class=\"hljs-keyword\">return</span> [state, dispatch, initState];\n}\n</pre>","type":"react","createTime":1605162462429,"updateTime":1606376897011,"description":"useReducer是不存在惰性的写法，但是如果需要大量计算得到状态数据的话，就有些尴尬了，所以整了这个"},{"id":6,"title":"有意思的useRef","icon":"","content":"<p>在同步异步时使用，简直不要太爽</p><p><br></p><p>也算是可以一定程度的减少组件更新次数</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">﻿<span class=\"hljs-comment\">// 也可以用来阻止渲染</span>\n<span class=\"hljs-comment\">// 有些时候我只想更新数据，不想更新组件</span>\n<span class=\"hljs-comment\">// 比如鼠标移入移除时我们只需要记录状态，等待下一次更新时拿到这个状态然后：</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">XLRef</span>() </span>{\n  <span class=\"hljs-keyword\">let</span> [up, setUp] = useState({}); <span class=\"hljs-comment\">// 更新组件的状态记录</span>\n  <span class=\"hljs-keyword\">let</span> stateRef = useRef({ <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> }); <span class=\"hljs-comment\">// 组件使用的状态数据</span>\n\n\n  <span class=\"hljs-comment\">// 状态数据更新，不是组件更新</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">assign</span>(<span class=\"hljs-params\">obj</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (obj) {\n      stateRef.current = <span class=\"hljs-built_in\">Object</span>.assign(stateRef.current, obj);\n    }\n  }\n  <span class=\"hljs-comment\">// 更新数据后，更新组件，可以不传数据，只更新组件</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">update</span>(<span class=\"hljs-params\">obj</span>) </span>{\n    assign(obj);\n    setUp({});\n  }\n\n\n  <span class=\"hljs-comment\">// 三个按键的点击事件</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onClick1</span>() </span>{\n    assign({ <span class=\"hljs-attr\">a</span>: stateRef.current.a + <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: stateRef.current.b - <span class=\"hljs-number\">1</span> });\n  }\n\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onClick2</span>() </span>{\n    update();\n  }\n\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onClick3</span>() </span>{\n    update({ <span class=\"hljs-attr\">a</span>: stateRef.current.a + <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: stateRef.current.b - <span class=\"hljs-number\">1</span> });\n  }\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      {JSON.stringify(stateRef.current)}\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onClick1}</span>&gt;</span>数据更新，组件不更新<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onClick2}</span>&gt;</span>数据不更新，组件更新<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onClick3}</span>&gt;</span>都更新<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  );\n}\n\n\n<span class=\"hljs-comment\">// 整成hook</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useRefState</span>(<span class=\"hljs-params\">initData</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> [up, setUp] = useState({});\n  <span class=\"hljs-keyword\">let</span> refObj = useRef(initData);\n  <span class=\"hljs-keyword\">let</span> state = refObj.current;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">update</span>(<span class=\"hljs-params\">obj</span>) </span>{\n    assign(obj);\n    setUp({});\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">assign</span>(<span class=\"hljs-params\">obj</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (obj) {\n      refObj.current = <span class=\"hljs-built_in\">Object</span>.assign(refObj.current, obj);\n      state = refObj.current;\n    }\n  }\n  <span class=\"hljs-comment\">// state 状态数据</span>\n  <span class=\"hljs-comment\">// update 组件更新</span>\n  <span class=\"hljs-comment\">// assign 数据合并</span>\n  <span class=\"hljs-keyword\">return</span> [state, update, assign];\n}\n\n\n<span class=\"hljs-comment\">// 改写XLRef</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">XLRef</span>() </span>{\n  <span class=\"hljs-keyword\">let</span> [state, update, assign] = useRefState({<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>})\n  <span class=\"hljs-comment\">// 三个按键的点击事件</span>\n\n  <span class=\"hljs-comment\">// 更新数据，但是组件不会更新</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onClick1</span>() </span>{\n    assign({ <span class=\"hljs-attr\">a</span>: state.a + <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: state.b - <span class=\"hljs-number\">1</span> });\n  }\n\n  <span class=\"hljs-comment\">// 更新组件，不会更新数据</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onClick2</span>() </span>{\n    update();\n  }\n\n  <span class=\"hljs-comment\">// 都更新</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onClick3</span>() </span>{\n    update({ <span class=\"hljs-attr\">a</span>: state.a + <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: state.b - <span class=\"hljs-number\">1</span> });\n  }\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      {JSON.stringify(state)}\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onClick1}</span>&gt;</span>数据更新，组件不更新<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onClick2}</span>&gt;</span>数据不更新，组件更新<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onClick3}</span>&gt;</span>都更新<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  );\n}\n\n\n\n</pre>","type":"react","createTime":1605162307810,"updateTime":1606378189764,"description":"useRef配合useState，玩起来很有意思，可以任意选择组件更新时机"},{"id":4,"title":"设计模式，职责链模式","icon":"","content":"<p>读 曾探 前辈的【JavaScript 设计模式与开发实践】一书，有感</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-comment\">// 此处例子是书中源码</span>\n<span class=\"hljs-keyword\">var</span> order500 = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">orderType, pay, stock</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (orderType === <span class=\"hljs-number\">1</span> &amp;&amp; pay === <span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"500 元定金预购，得到 100 优惠券\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"nextSuccessor\"</span>; <span class=\"hljs-comment\">// 我不知道下一个节点是谁，反正把请求往后面传递</span>\n  }\n};\n<span class=\"hljs-keyword\">var</span> order200 = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">orderType, pay, stock</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (orderType === <span class=\"hljs-number\">2</span> &amp;&amp; pay === <span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"200 元定金预购，得到 50 优惠券\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"nextSuccessor\"</span>; <span class=\"hljs-comment\">// 我不知道下一个节点是谁，反正把请求往后面传递 }</span>\n  }\n};\n<span class=\"hljs-keyword\">var</span> orderNormal = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">orderType, pay, stock</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (stock &gt; <span class=\"hljs-number\">0</span>) {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"普通购买，无优惠券\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"手机库存不足\"</span>);\n  }\n};\n<span class=\"hljs-keyword\">var</span> Chain = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">fn</span>) </span>{\n  <span class=\"hljs-built_in\">this</span>.fn = fn;\n  <span class=\"hljs-built_in\">this</span>.successor = <span class=\"hljs-literal\">null</span>;\n};\nChain.prototype.setNextSuccessor = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">successor</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">this</span>.successor = successor);\n};\nChain.prototype.passRequest = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n  <span class=\"hljs-keyword\">return</span> ret;\n};\n<span class=\"hljs-keyword\">var</span> ret = <span class=\"hljs-built_in\">this</span>.fn.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n<span class=\"hljs-keyword\">if</span> (ret === <span class=\"hljs-string\">\"nextSuccessor\"</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-built_in\">this</span>.successor &amp;&amp;\n    <span class=\"hljs-built_in\">this</span>.successor.passRequest.apply(<span class=\"hljs-built_in\">this</span>.successor, <span class=\"hljs-built_in\">arguments</span>)\n  );\n}\n<span class=\"hljs-keyword\">var</span> chainOrder500 = <span class=\"hljs-keyword\">new</span> Chain(order500);\n<span class=\"hljs-keyword\">var</span> chainOrder200 = <span class=\"hljs-keyword\">new</span> Chain(order200);\n<span class=\"hljs-keyword\">var</span> chainOrderNormal = <span class=\"hljs-keyword\">new</span> Chain(orderNormal);\nchainOrder500.setNextSuccessor(chainOrder200);\nchainOrder200.setNextSuccessor(chainOrderNormal);\nchainOrder500.passRequest(<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">500</span>); <span class=\"hljs-comment\">// 输出:500 元定金预购，得到 100 优惠券</span>\nchainOrder500.passRequest(<span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">500</span>); <span class=\"hljs-comment\">// 输出:200 元定金预购，得到 50 优惠券</span>\nchainOrder500.passRequest(<span class=\"hljs-number\">3</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">500</span>); <span class=\"hljs-comment\">// 输出:普通购买，无优惠券</span>\nchainOrder500.passRequest(<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 输出:手机库存不足</span>\n\n\n<span class=\"hljs-comment\">// 此处为个人想法</span>\n<span class=\"hljs-comment\">// 这种职责链模式也挺有意思的，可以任意改动执行顺序</span>\n<span class=\"hljs-keyword\">let</span> mode1 = [order500, order200, orderNormal];\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">mode, ...args</span>) </span>{\n  mode.some(<span class=\"hljs-function\">(<span class=\"hljs-params\">fn</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (fn.apply(<span class=\"hljs-literal\">null</span>, args) !== <span class=\"hljs-string\">\"nextSuccessor\"</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n  });\n}\nrender(mode1, <span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">500</span>);\n</pre>","type":"javascript","createTime":1605162030858,"updateTime":1606376870551,"description":"读 曾探 前辈的【JavaScript 设计模式与开发实践】一书，有感"},{"id":3,"title":"react 重置组件","icon":"","content":"<p>组件重置，还原组件，react</p><p><br></p><p>利用虚拟DOM更新原理</p><p><br></p><p>虽然用的机会不多，但确实有时候需要一个，多是配合第三方非react写的插件时</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-comment\">// 高阶组件，props 传入 _factor参数，参数改变时会重新渲染组件，不保存任何状态，相当于重置</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resetCom</span>(<span class=\"hljs-params\">Com, val</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">props</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> [num, setNum] = useState(val);\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">Object</span>.is(props._factor, num)) {\n      <span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\">() =&gt;</span> {\n        setNum(props._factor);\n      });\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;&lt;/<span class=\"hljs-name\">div</span>&gt;</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Com</span> {<span class=\"hljs-attr\">...props</span>} /&gt;</span>;\n  };\n}\n\n<span class=\"hljs-comment\">// 使用</span>\n\n<span class=\"hljs-comment\">// 包装需要重置的组件</span>\n<span class=\"hljs-keyword\">const</span> Box = resetCom(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n  <span class=\"hljs-keyword\">let</span> [num, setNum] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>这里是 App的子组件 , Box 组件<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>点击改变Box 的 状态数据<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setNum(num + 1)}&gt;Box {num}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  );\n});\n\n<span class=\"hljs-comment\">// 使用需要重置组件的组件</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>() </span>{\n  <span class=\"hljs-comment\">// 当数据改变时会重置Box组件，清除状态（重置组件）</span>\n  <span class=\"hljs-keyword\">let</span> [num, setNum] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>这里是 App 组件<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>点击改变App状态数据，从而重置 Box组件的状态<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setNum(num + 1)}&gt;App {num}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">height:</span> \"<span class=\"hljs-attr\">30px</span>\" }}&gt;&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Box</span> <span class=\"hljs-attr\">_factor</span>=<span class=\"hljs-string\">{num}</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  );\n}\n</pre>","type":"react","createTime":1605161963162,"updateTime":1606377939478,"description":"重置组件，还原组件，还原状态"},{"id":2,"title":"vue+koa2框架模板","icon":"","content":"<p>找了好久的前后台一起的项目模板，没有找到还不错的，最近自己动手搞了个 </p><p><br></p><p>如果哪位大神有很好的模板欢迎推荐给在下</p><p><br></p><p>上地址 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/tiandao5d/kvxl.git\" rel=\"noopener noreferrer\" target=\"_blank\">https://link.zhihu.com/?target=https%3A//github.com/tiandao5d/kvxl.git</a></p>","type":"vue","createTime":1605161279573,"updateTime":1606377155646,"description":"很早以前整的，原先还妄称全栈，其实不过是个前后台代码放一起的简单模板"}]}