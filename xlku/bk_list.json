{"id":13,"items":[{"id":13,"title":"命令模式","icon":"","description":"读曾探前辈【JavaScript设计模式与开发实践】有感","content":"<pre class=\"ql-syntax\" spellcheck=\"false\">    // 书中源码\n    var Ryu = {\n      attack: function () {\n        console.log('攻击');\n      },\n      defense: function () {\n        console.log('防御');\n      },\n      jump: function () {\n        console.log('跳跃');\n      },\n      crouch: function () {\n        console.log('蹲下');\n      }\n    };\n    var makeCommand = function (receiver, state) { // 创建命令\n      return function () {\n        receiver[state]();\n      }\n    };\n    var commands = {\n      \"119\": \"jump\", // W\n      \"115\": \"crouch\", // S\n      \"97\": \"defense\", // A\n      \"100\": \"attack\" // D\n    };\n    var commandStack = []; // 保存命令的堆栈\n    document.onkeypress = function (ev) {\n      var keyCode = ev.keyCode,\n        command = makeCommand(Ryu, commands[keyCode]);\n      if (command) {\n        command(); // 执行命令\n        commandStack.push(command); // 将刚刚执行过的命令保存进堆栈\n      }\n    };\n    document.getElementById('replay').onclick = function () { // 点击播放录像\n      var command;\n      while (command = commandStack.shift()) { // 从堆栈里依次取出命令并执行\n        command();\n      }\n    };\n\n\n    // 以下为个人想法\n\n    // 不在是创建命令，而是直接执行\n    makeCommand = function (receiver, state) { // 执行命令\n      receiver[state]();\n    };\n    document.onkeypress = function (ev) {\n      var keyCode = ev.keyCode;\n      if (commands[keyCode]) { // 当按键无效时，减少了命令创建这一步\n        // 不保存命令，而是保存参数，保存参数后，\n        // 那后面执行时，如果源命令函数发生变化，也可以得到最新命令\n        // 同时，还可以给命令增加和修改参数\n        var args = [Ryu, commands[keyCode]];\n        makeCommand(...args); // 执行命令\n        commandStack.push(args); // 保存参数\n      }\n    };\n    document.getElementById('replay').onclick = function () { // 点击播放录像\n      var args;\n      while (args = commandStack.shift()) { // 从堆栈里依次取出命令参数并执行\n        makeCommand(...args);\n      }\n    };\n</pre>","type":"javascript","createTime":1605850265031,"updateTime":0},{"id":12,"title":"缓存机制","icon":"","description":"早先主要是为了缓存请求数据，也是为了防止以前旧项目中的经常出现多次同样请求的情况写的","content":"<p>以前旧项目中各组件确实需要请求同一个接口，参数有时相同有时不同</p><p><br></p><p>写了这个缓存且是异步执行的方法</p><p><br></p><p>异步执行参考了vue的异步更新，也有些计算属性的调调</p><p><br></p><p>理念同样可以用于普通函数的缓存计算结果</p><p><br></p><p>也给了简单的缓存自动清理机制</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// 异步函数执行缓存\n// fn 一个promise的异步函数，会将返回值缓存\n// 同时多次请求时，会等待第一次的返回结果之后在执行列队请求\n// 有点vue计算属性的调调，也参考了vue的异步更新机制\ninterface SCItem {\n  key: string; // 关键key值，判断是否可以使用缓存\n  args: any; // 函数形参\n  res: any; // 记录正确返回\n  ts: number; // 记录时间戳\n  err: any; // 记录错误返回\n  cbs: any[]; // 记录回调队列\n}\nconst syncCache = (function () {\n  let tt = 10 * 60 * 1000; // 默认时间\n  function clearCache(time: number, fn: Function) {\n    setTimeout(function () {\n      fn();\n      clearCache(time, fn);\n    }, time);\n  }\n  // cacheTime 缓存时间\n  // clearTime 缓存清除间隔时间\n  return function syncCache(fn: Function, cacheTime?: number, clearTime = tt) {\n    // 列队等待的数据\n    let cacheData = {};\n    let args = Array.prototype.slice.call(arguments, 3);\n    let that = this;\n    // 缓存时间毫秒数，超过这个时间会重新请求\n    cacheTime = cacheTime &gt; 0 ? cacheTime : tt;\n    // 简单的垃圾清除机制\n    // 一定的时间内清空缓存\n    if (clearTime &gt; 0) {\n      clearCache(clearTime, function () {\n        cacheData = {};\n      });\n    }\n\n\n    // 以key为唯一值，加入缓存列队，args为fn的执行参数\n    function addCacheQueue(key: string, args: any) {\n      let item: SCItem = cacheData[key];\n      let curTime = +new Date();\n      // 已经执行过异步函数，得到异步返回值了，在缓存时间内，所以直接返回内容\n      if (item) {\n        if (item.res) {\n          if (curTime - item.ts &lt; cacheTime) {\n            // 如果经常使用，则继续缓存，重置上次缓存时间\n            //  称之为频率缓存\n            item.ts = curTime;\n            // 拷贝返回\n            return Promise.resolve(copy(item.res));\n          } else {\n            item = null;\n          }\n        } else if (item.err) {\n          item = null;\n        }\n      }\n      return new Promise((resolve) =&gt; {\n        // 已经执行了异步函数，但是没有返回，记录列队\n        if (item) {\n          item.cbs.push(resolve);\n        } else {\n          // 执行异步函数\n          item = {\n            key,\n            args,\n            ts: 0, // 记录时间戳\n            res: null, // 记录正确返回\n            err: null, // 记录错误返回\n            cbs: [resolve],\n          };\n          // 加入列队数据，向前添加\n          cacheData[key] = item;\n          tryFn(item);\n        }\n      });\n    }\n\n\n    // 执行函数\n    function tryFn(item: SCItem) {\n      return fn\n        .apply(that, item.args)\n        .then((res: any) =&gt; {\n          item.res = res;\n          // 请求成功后开始记录缓存时间\n          item.ts = +new Date();\n          return res;\n        })\n        .catch((err: any) =&gt; {\n          item.err = err;\n          return err;\n        })\n        .finally(() =&gt; {\n          // 执行列队回调\n          // 拷贝返回\n          item.cbs.forEach((cb: (arg0: any, arg1: any) =&gt; any) =&gt;\n            cb(copy(item.res), item.err)\n          );\n          // 置空列队回调\n          item.cbs = [];\n          return 0;\n        });\n    }\n\n\n    return function (...newArgs) {\n      // 可以为缓存的唯一值\n      let key = newArgs.pop();\n      newArgs = args.concat(newArgs);\n      // 判断key有效，也就是函数的最后一个参数是可以用来当成key的，自定义key\n      // 无效的话直接将参数转成字符串作为key\n      if (!(key &amp;&amp; typeof key === \"string\" &amp;&amp; key.startsWith(\"_XLKEY\"))) {\n        newArgs.push(key);\n        key = JSON.stringify(newArgs); // 参数为key值，用于缓存的key\n      }\n      return addCacheQueue(key, newArgs);\n    };\n  };\n})();\n</pre>","type":"javascript","createTime":1605844007790,"updateTime":1605844104123},{"id":11,"title":"深层的对象合并，数据补全","icon":"","description":"针对后台数据一些字段有时存在有时不存在，算是一个深层的Object.assign方法，主要用途是数据补全","content":"<p>也是旧项目中，后台数据不全，字段有时存在有时不存在，导致后续要多很多判断</p><p><br></p><p>所以写了这个方法</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// 此方法为深层次的对象合并，但不考虑深拷贝，只考虑对象 [object, Object]，\n// 不考虑数组，函数，时间等引用类型，一个深层次的 Object.assign方法\n// 主要用途是数据补全，给一个默认格式，然后可以默认补全后面的数据\n// 保证数据的完整性\nconst assignObj = (function assignObj() {\n  function fn(obj1, obj2) {\n    for (let k in obj2) {\n      let val1 = obj1[k];\n      let val2 = obj2[k];\n      if (isObject(val1) &amp;&amp; isObject(val2)) {\n        obj1[k] = fn(val1, val2);\n      } else if (isObject(val2)) {\n        // 此时不能直接赋值，否则obj2的值可能会被改变\n        // 因为直接赋值了一个引用类型，下次循环时可能会改变这个引用类型\n        // 进行直接拷贝然后再赋值相当于拷贝了一份引用类型的基础结构\n        // 而不是直接使用后面的引用类型，无需精准的拷贝，因为只需要基础结构即可\n        val1 = JSON.parse(JSON.stringify(val2));\n        obj1[k] = fn(val1, val2);\n      } else {\n        obj1[k] = val2;\n      }\n    }\n    return obj1;\n  }\n  return function (item1, ...args) {\n    if (!(args.length &gt; 0)) {\n      return item1;\n    }\n    return args.reduce((total, item) =&gt; {\n      return fn(total, item);\n    }, item1);\n  };\n})();\n</pre>","type":"javascript","createTime":1605843126390,"updateTime":1605843196280},{"id":10,"title":"简单的提示工具","icon":"","description":"这是原先一个旧项目中各种提示工具整的我烦死了，才想了写一个简单提示工具玩一玩，配合animate.css一起各种动效，有点意思","content":"<p><a href=\"https://tiandao5d.github.io/xlToast/\" rel=\"noopener noreferrer\" target=\"_blank\">示例</a></p><p><br></p><p><a href=\"https://github.com/tiandao5d/xlToast\" rel=\"noopener noreferrer\" target=\"_blank\">源码</a></p>","type":"javascript","createTime":1605842873120,"updateTime":0},{"id":9,"title":"发布订阅模式","icon":"","description":"自写的发布订阅模式，和市面上的差别在于，写了一个只响应最后一次监听的回调函数","content":"<p>自写的发布订阅模式，和市面上的差别在于，写了一个只响应最后一次监听的回调函数</p><p><br></p><p>也是以前一个旧项目中的为了减少重复监听问题</p><p><br></p><p>一种偷懒的方法，如果不知何种时机（或者是根本不想管）清除监听副作用时，配合代理模式一起，当年玩的是不要太爽</p><p><br></p><p>那时typescript使用不熟，欢迎批评教育</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// eventType 事件名称， eventKey 事件名称空间， eventFn 事件绑定的函数，\n// mode 事件绑定的模式, on 正常监听 once 只执行一次的监听\n// mode ronce 只能绑定一个函数的监听， eventKey下数组只能有一个绑定函数后面的会覆盖前面的\n// data结构 {eventType: {eventKey: [ { eventFn, mode } ]}}\n/**\n * let xlEventCls = new XLEvents();\n * // 一下a为事件名称，b为命名空间\n * // 会触发a事件名称下的所有命名空间\n * xlEventCls.emit('a', 1, 2);\n * // 支付触发a事件名下的b命名空间\n * xlEventCls.emit('a.b', 1, 2);\n * // 普通监听，执行一次会多出一个函数监听\n * xlEventCls.on('a.b',()=&gt;{});\n * xlEventCls.on('a.b',()=&gt;{}, 'on');\n * // 只会触发一次的监听，触发一次后会删除监听\n * // 同一事件名称中的同一个命名空间可以有多个once的类型\n * xlEventCls.once('a.b',()=&gt;{});\n * xlEventCls.on('a.b',()=&gt;{}, 'once');\n * // 防止重复监听\n * // 和普通的差不多，只是在同一个事件名称下的同一个命名空间只会触发最后一次的监听函数\n * // 为了防止重复监听带来的副作用\n * xlEventCls.ronce('a.b',()=&gt;{});\n * xlEventCls.on('a.b',()=&gt;{}, 'ronce');\n * // 监听时也可以不加命名空间，会默认给命名空间 $xl_default_ll，事件名称也是一样默认 $xl_default_ll\n * // 所以请不要给出和 $xl_default_ll 一样的命名，否则可能会出现BUG\n */\ntype Mode = \"on\" | \"once\" | \"ronce\";\ninterface XLEItem {\n  eventFn: Function;\n  mode: Mode;\n}\ninterface XLEData {\n  [eventType: string]: {\n    [eventKey: string]: XLEItem[];\n  };\n}\nclass XLEvents {\n  data: XLEData;\n  modeArr: string[];\n  dkey: string;\n  constructor() {\n    // 数据函数存储\n    this.data = {};\n    // 可用的事件监听模式\n    this.modeArr = [\"on\", \"once\", \"ronce\"];\n    // 如果碰巧名称一样，那抱歉了，bug\n    this.dkey = \"$xl_default_ll\";\n  }\n  formatType(type: string, isd?: boolean) {\n    let arr = type.split(\".\");\n    let eventType = arr[0] || this.dkey; // 事件名称\n    let eventKey = arr[1] ? arr[1] : isd ? this.dkey : ''; // 事件命名空间\n  \n    // 事件属性下的所有命名空间对象，是个对象\n    let tItem = this.data[eventType] ? { ...this.data[eventType] } : {};\n    // 单个命名空间对象数据，是个数组XLEItem[]\n    let kItem = tItem[eventKey] ? [...tItem[eventKey]] : [];\n    return { eventType, eventKey, tItem, kItem };\n  }\n  // 监听时如果没有事件名称或命名空间，都会给默认值\n  on(type: any, eventFn: Function, mode: Mode = \"on\") {\n    let { eventType, eventKey, tItem, kItem } = this.formatType(type, true);\n    if (!this.modeArr.includes(mode)) {\n      mode = \"on\";\n    }\n    if (\n      typeof eventFn === \"function\" &amp;&amp;\n      !kItem.some((item) =&gt; item.eventFn === eventFn)\n    ) {\n      let eItem: XLEItem = { eventFn, mode };\n      // 只会监听一个函数，后面的函数监听会覆盖前面的\n      // 同一个命名空间只能有一个 'ronce' 的属性\n      // 但是可以同时存在多个其他类型的监听\n      if (mode === \"ronce\") {\n        kItem = kItem.filter((o) =&gt; o.mode !== \"ronce\");\n      }\n      kItem.push(eItem);\n    }\n    tItem[eventKey] = kItem;\n    this.data[eventType] = tItem;\n    return this;\n  }\n  // 如果type值相同的话，只会响应最后一次的回调函数\n  // 一种减少副作用的方法，防止多次重复监听\n  ronce(type: any, eventFn: any) {\n    return this.on(type, eventFn, \"ronce\");\n  }\n  // 只执行一次，没啥不同的\n  once(type: any, eventFn: any) {\n    return this.on(type, eventFn, \"once\");\n  }\n  emitKItem(kItem: any[], args: any[]) {\n    kItem = kItem.filter((eItem: { eventFn: any; mode: string }) =&gt; {\n      let fn = eItem.eventFn;\n      try {\n        fn(...args);\n      } catch (error) {\n        console.log(error);\n        return false;\n      }\n      // 只监听一次的，之后会直接删除\n      if (eItem.mode === \"once\") {\n        return false;\n      }\n      return true;\n    });\n    return kItem;\n  }\n\n\n  // 触发时，如果没有命名空间\n  // 会触发此事件下所有的事件绑定\n  emit(type: any, ...args: any[]) {\n    let { eventType, eventKey, tItem, kItem } = this.formatType(type);\n    // 触发此事件下所有的事件绑定\n    if (!eventKey) {\n      for (let k in tItem) {\n        if (tItem[k] &amp;&amp; tItem[k].length) {\n          tItem[k] = this.emitKItem(tItem[k], args);\n        }\n      }\n      this.data[eventType] = tItem;\n      return this;\n    }\n    if (kItem &amp;&amp; kItem.length) {\n      kItem = this.emitKItem(kItem, args);\n      tItem[eventKey] = kItem;\n      this.data[eventType] = tItem;\n    }\n    return this;\n  }\n\n\n  // 解除绑定时， 如果没有命名空间\n  // 则清空此事件下所有的监听\n  off(type: any, eventFn?: Function) {\n    let { eventType, eventKey, tItem, kItem } = this.formatType(type);\n    // 清空此事件下所有的事件绑定\n    if (!eventKey) {\n      this.data[eventType] = {};\n      return this;\n    }\n    if (kItem &amp;&amp; kItem.length) {\n      if (typeof eventFn === \"function\") {\n        // 删掉单个监听\n        kItem = kItem.filter((item) =&gt; item.eventFn !== eventFn);\n      } else {\n        // 删除整个组的\n        kItem = [];\n      }\n      tItem[eventKey] = kItem;\n      this.data[eventType] = tItem;\n    }\n    return this;\n  }\n}\n</pre>","type":"javascript","createTime":1605842245152,"updateTime":1605842434936},{"id":8,"title":"列表选择类","icon":"","description":"公司项目中，很多需要做列表的展现和选择点击的，所以封装了这个类","content":"<pre class=\"ql-syntax\" spellcheck=\"false\">  class ListMultiple {\n    constructor(options = {}) {\n      this.min = options.min || 0;\n      this.max = options.max || 0;\n      if (this.min &gt; 0 &amp;&amp; this.max &gt; 0 &amp;&amp; this.max &lt; this.min) {\n        this.min = 0;\n        this.max = 0;\n        console.log(\"参数错误，min 不能大于 max\");\n      }\n      this.dOptions = { ...options };\n      this.resetItems({}, { type: \"$_lm_init\" });\n    }\n\n\n    // 重置项目数据\n    resetItems(options = {}, eventData) {\n      options = { ...this.dOptions, ...options };\n      this.dOptions = options;\n      let selectInOri =\n        typeof options.selectInOri === \"boolean\"\n          ? options.selectInOri\n          : typeof this.selectInOri === \"boolean\"\n          ? this.selectInOri\n          : false;\n      let oriItems = options.oriItems || this.oriItems || [];\n      let selectItems = options.selectItems || this.selectItems || [];\n      let k =\n        options.k || this.k || (oriItems[0] &amp;&amp; oriItems[0].id ? \"id\" : \"\");\n\n\n      // 有从属关系，selectItems 的数据必须存在于 oriItems中\n      if (selectInOri) {\n        selectItems = this.filterEvery12(selectItems, oriItems);\n      }\n      // oriItems - selectItems = listItems\n      let listItems = this.filterSome1(oriItems, selectItems);\n      if (!(eventData &amp;&amp; eventData.type === \"$_lm_init\")) {\n        // 选中数据不能少于\n        if (this.min &gt; 0) {\n          if (selectItems.length &lt; this.min) {\n            this.onError(\"min_err\", {\n              txt: `选中的数据量不能小于给定的 min: ${this.min}`,\n              items: [...selectItems],\n            });\n            return this;\n          }\n        }\n\n\n        // 选中数据不能大于\n        if (this.max &gt; 0) {\n          if (selectItems.length &gt; this.max) {\n            this.onError(\"max_err\", {\n              txt: `选中的数据量不能小于给定的 max: ${this.max}`,\n              items: [...selectItems],\n            });\n            return this;\n          }\n        }\n      }\n\n\n      // 原始列表数据\n      this.oriItems = [...oriItems];\n      // 选中列表数据\n      this.selectItems = [...selectItems];\n      // 原始 - 选中\n      this.listItems = [...listItems];\n      // 对比两个列表项目相等的 key 值\n      this.k = k;\n      // 是否有从属关系，selectItems中元素 是否必须是存在于 oriItems中\n      this.selectInOri = selectInOri;\n      if (eventData &amp;&amp; eventData.type !== \"$_lm_init\") {\n        eventData.target = this;\n        this.emitChange(eventData.type, eventData);\n      }\n      return this;\n    }\n    // 差集，1有，2没有\n    filterSome1(items1, items2, k = this.k) {\n      if (k) {\n        return items1.filter((o) =&gt; !items2.some((oo) =&gt; o[k] === oo[k]));\n      }\n      return items1.filter((o) =&gt; !items2.some((oo) =&gt; o === oo));\n    }\n    // 交集，1和2同时拥有\n    filterEvery12(items1, items2, k = this.k) {\n      if (k) {\n        return items1.filter((o) =&gt; items2.some((oo) =&gt; o[k] === oo[k]));\n      }\n      return items1.filter((o) =&gt; items2.some((oo) =&gt; o === oo));\n    }\n    hasSelect(item, k = this.k) {\n      // 判断指定项目是否是选中的状态\n      if (k) {\n        return this.selectItems.some((o) =&gt; o[k] === item[k]);\n      }\n      return this.selectItems.some((o) =&gt; o === item);\n    }\n    // 简单的数据转化，因为这里是对数组进行操作\n    toArr(item) {\n      let items = null;\n      if (item instanceof Array) {\n        items = item;\n      } else {\n        items = [item];\n      }\n      return items;\n    }\n    onError() {}\n    onChange() {}\n    emitChange() {\n      this.onChange(...arguments);\n      return this;\n    }\n    hasAll(k = this.k) {\n      // 判断是否全选\n      if (k) {\n        return (\n          this.oriItems.length === this.selectItems.length &amp;&amp;\n          this.oriItems.every((o) =&gt;\n            this.selectItems.some((oo) =&gt; o[k] === oo[k])\n          )\n        );\n      }\n      return (\n        this.oriItems.length === this.selectItems.length &amp;&amp;\n        this.oriItems.every((o) =&gt; this.selectItems.some((oo) =&gt; o === oo))\n      );\n    }\n    toggleAll() {\n      // 切换全选状态\n      if (this.hasAll()) {\n        this.clearItems();\n      } else {\n        this.allItems();\n      }\n      return this;\n    }\n    allItems() {\n      // 全选数据\n      this.resetItems(\n        {\n          selectItems: this.oriItems,\n          oriItems: this.oriItems,\n        },\n        {\n          type: \"all\",\n        }\n      );\n      return this;\n    }\n    clearItems() {\n      // 清空数据\n      this.resetItems(\n        {\n          selectItems: [],\n        },\n        {\n          type: \"clear\",\n        }\n      );\n      return this;\n    }\n    onToggleItems(item) {\n      // 切换选中与不选中\n      let items = this.toArr(item);\n      // 过滤出选中状态中没有的数据才有添加的意义\n      let addItems = this.filterSome1(items, this.selectItems);\n      // 过滤出选中状态中有的数据，才有删除的意义\n      let removeItems = this.filterEvery12(items, this.selectItems);\n      // 有需要添加的数据\n      if (addItems.length) {\n        this.onSelectItems(addItems);\n      }\n      // 有需要删除的数据\n      if (removeItems.length) {\n        this.onRemoveItems(removeItems);\n      }\n      return this;\n    }\n    onSelectItems(item) {\n      let items = this.toArr(item); // 转数组\n      // 过滤出选中状态中没有的数据才有添加的意义\n      items = this.filterSome1(items, this.selectItems);\n      if (items.length) {\n        let selectItems = [...this.selectItems, ...items];\n        this.resetItems(\n          {\n            selectItems,\n          },\n          {\n            type: \"select\",\n            items: [...items],\n          }\n        );\n      }\n      return this;\n    }\n    onRemoveItems(item) {\n      let items = this.toArr(item);\n      // 过滤出选中状态中有的数据，才有删除的意义\n      items = this.filterEvery12(items, this.selectItems);\n      if (items.length) {\n        let selectItems = this.filterSome1(this.selectItems, items);\n        this.resetItems(\n          {\n            selectItems,\n          },\n          {\n            type: \"remove\",\n            items: [...items],\n          }\n        );\n      }\n      return this;\n    }\n  }\n</pre>","type":"javascript","createTime":1605841541605,"updateTime":0},{"id":7,"title":"让 useReducer 可以使用惰性 state","icon":"","content":"<p>在使用useReducer 时，发现这个鬼记录的state没有惰性功能</p><p><br></p><p>如果我要记录的state的初始值需要经过大量计算得到，那就有点尴尬了</p><p><br></p><p>然后就想了个简单办法，借用useState的惰性功能</p><p><br></p><p>自定义hook代码如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">function useXLReducer(_state) {\n  function reducer(state, action) {\n    // ... 一些操作\n    return { ...state};\n  }\n  // 这个是惰性的，如果_state是一个函数，会惰性执行\n  // 这个状态只会被第一次用到，也是保存了初始值\n  // 这样就可以让 useReducer 这个 hook 转为惰性的\n  // 支持传入的_state是一个函数\n  const [initState] = useState(_state);\n  const [state, dispatch] = useReducer(reducer, initState);\n\n\n  // 看个人喜好 可以将初始值 initState 保存下来\n  return [state, dispatch, initState];\n}\n</pre>","type":"react","createTime":1605162462429,"updateTime":1605851183219,"description":"useReducer是不存在惰性的写法，但是如果需要大量计算得到状态数据的话，就有些尴尬了，所以整了这个"},{"id":6,"title":"有意思的useRef","icon":"","content":"<pre class=\"ql-syntax\" spellcheck=\"false\">// 也可以用来阻止渲染\n// 有些时候我只想更新数据，不想更新组件\n// 比如鼠标移入移除时我们只需要记录状态，等待下一次更新时拿到这个状态然后：\n\nfunction XLRef() {\n  let [up, setUp] = useState({}); // 更新组件的状态记录\n  let stateRef = useRef({ a: 1, b: 2 }); // 组件使用的状态数据\n\n\n  // 状态数据更新，不是组件更新\n  function assign(obj) {\n    if (obj) {\n      stateRef.current = Object.assign(stateRef.current, obj);\n    }\n  }\n  // 更新数据后，更新组件，可以不传数据，只更新组件\n  function update(obj) {\n    assign(obj);\n    setUp({});\n  }\n\n\n  // 三个按键的点击事件\n  function onClick1() {\n    assign({ a: stateRef.current.a + 1, b: stateRef.current.b - 1 });\n  }\n\n\n  function onClick2() {\n    update();\n  }\n\n\n  function onClick3() {\n    update({ a: stateRef.current.a + 1, b: stateRef.current.b - 1 });\n  }\n  return (\n    &lt;div&gt;\n      {JSON.stringify(stateRef.current)}\n      &lt;button onClick={onClick1}&gt;数据更新，组件不更新&lt;/button&gt;\n      &lt;button onClick={onClick2}&gt;数据不更新，组件更新&lt;/button&gt;\n      &lt;button onClick={onClick3}&gt;都更新&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\n\n// 整成hook\nfunction useRefState(initData) {\n  let [up, setUp] = useState({});\n  let refObj = useRef(initData);\n  let state = refObj.current;\n  function update(obj) {\n    assign(obj);\n    setUp({});\n  }\n  function assign(obj) {\n    if (obj) {\n      refObj.current = Object.assign(refObj.current, obj);\n      state = refObj.current;\n    }\n  }\n  // state 状态数据\n  // update 组件更新\n  // assign 数据合并\n  return [state, update, assign];\n}\n\n\n// 改写XLRef\nfunction XLRef() {\n  let [state, update, assign] = useRefState({a: 1, b: 2})\n  // 三个按键的点击事件\n\n  // 更新数据，但是组件不会更新\n  function onClick1() {\n    assign({ a: state.a + 1, b: state.b - 1 });\n  }\n\n  // 更新组件，不会更新数据\n  function onClick2() {\n    update();\n  }\n\n  // 都更新\n  function onClick3() {\n    update({ a: state.a + 1, b: state.b - 1 });\n  }\n  return (\n    &lt;div&gt;\n      {JSON.stringify(state)}\n      &lt;button onClick={onClick1}&gt;数据更新，组件不更新&lt;/button&gt;\n      &lt;button onClick={onClick2}&gt;数据不更新，组件更新&lt;/button&gt;\n      &lt;button onClick={onClick3}&gt;都更新&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\n\n\n</pre>","type":"react","createTime":1605162307810,"updateTime":1605851174612,"description":"useRef配合useState，玩起来很有意思，可以任意选择组件更新时机"},{"id":4,"title":"设计模式，职责链模式","icon":"","content":"<p>读 曾探 前辈的【JavaScript 设计模式与开发实践】一书，有感</p><pre class=\"ql-syntax\" spellcheck=\"false\">// 此处例子是书中源码\nvar order500 = function (orderType, pay, stock) {\n  if (orderType === 1 &amp;&amp; pay === true) {\n    console.log(\"500 元定金预购，得到 100 优惠券\");\n  } else {\n    return \"nextSuccessor\"; // 我不知道下一个节点是谁，反正把请求往后面传递\n  }\n};\nvar order200 = function (orderType, pay, stock) {\n  if (orderType === 2 &amp;&amp; pay === true) {\n    console.log(\"200 元定金预购，得到 50 优惠券\");\n  } else {\n    return \"nextSuccessor\"; // 我不知道下一个节点是谁，反正把请求往后面传递 }\n  }\n};\nvar orderNormal = function (orderType, pay, stock) {\n  if (stock &gt; 0) {\n    console.log(\"普通购买，无优惠券\");\n  } else {\n    console.log(\"手机库存不足\");\n  }\n};\nvar Chain = function (fn) {\n  this.fn = fn;\n  this.successor = null;\n};\nChain.prototype.setNextSuccessor = function (successor) {\n  return (this.successor = successor);\n};\nChain.prototype.passRequest = function () {\n  return ret;\n};\nvar ret = this.fn.apply(this, arguments);\nif (ret === \"nextSuccessor\") {\n  return (\n    this.successor &amp;&amp;\n    this.successor.passRequest.apply(this.successor, arguments)\n  );\n}\nvar chainOrder500 = new Chain(order500);\nvar chainOrder200 = new Chain(order200);\nvar chainOrderNormal = new Chain(orderNormal);\nchainOrder500.setNextSuccessor(chainOrder200);\nchainOrder200.setNextSuccessor(chainOrderNormal);\nchainOrder500.passRequest(1, true, 500); // 输出:500 元定金预购，得到 100 优惠券\nchainOrder500.passRequest(2, true, 500); // 输出:200 元定金预购，得到 50 优惠券\nchainOrder500.passRequest(3, true, 500); // 输出:普通购买，无优惠券\nchainOrder500.passRequest(1, false, 0); // 输出:手机库存不足\n\n\n// 此处为个人想法\n// 这种职责链模式也挺有意思的，可以任意改动执行顺序\nlet mode1 = [order500, order200, orderNormal];\nfunction render(mode, ...args) {\n  mode.some((fn) =&gt; {\n    if (fn.apply(null, args) !== \"nextSuccessor\") {\n      return true;\n    }\n  });\n}\nrender(mode1, 1, true, 500);\n</pre>","type":"javascript","createTime":1605162030858,"updateTime":1605839196487,"description":"读 曾探 前辈的【JavaScript 设计模式与开发实践】一书，有感"},{"id":3,"title":"react 重置组件","icon":"","content":"<p>组件重置，还原组件，react</p><p><br></p><p>利用虚拟DOM更新原理</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// 高阶组件，props 传入 _factor参数，参数改变时会重新渲染组件，不保存任何状态，相当于重置\nfunction resetCom(Com, val) {\n  return function (props) {\n    let [num, setNum] = useState(val);\n    if (!Object.is(props._factor, num)) {\n      Promise.resolve().then(() =&gt; {\n        setNum(props._factor);\n      });\n      return &lt;div&gt;&lt;/div&gt;;\n    }\n    return &lt;Com {...props} /&gt;;\n  };\n}\n\n// 使用\n\n// 包装需要重置的组件\nconst Box = resetCom(function () {\n  let [num, setNum] = useState(0);\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;这里是 App的子组件 , Box 组件&lt;/h3&gt;\n      &lt;p&gt;点击改变Box 的 状态数据&lt;/p&gt;\n      &lt;button onClick={() =&gt; setNum(num + 1)}&gt;Box {num}&lt;/button&gt;\n    &lt;/div&gt;\n  );\n});\n\n// 使用需要重置组件的组件\nfunction App() {\n  // 当数据改变时会重置Box组件，清除状态（重置组件）\n  let [num, setNum] = useState(0);\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;这里是 App 组件&lt;/h3&gt;\n      &lt;p&gt;点击改变App状态数据，从而重置 Box组件的状态&lt;/p&gt;\n      &lt;button onClick={() =&gt; setNum(num + 1)}&gt;App {num}&lt;/button&gt;\n      &lt;p style={{ height: \"30px\" }}&gt;&lt;/p&gt;\n      &lt;Box _factor={num} /&gt;\n    &lt;/div&gt;\n  );\n}\n</pre>","type":"react","createTime":1605161963162,"updateTime":1605851163214,"description":"重置组件，还原组件，还原状态"},{"id":2,"title":"vue+koa2框架模板","icon":"","content":"<p>找了好久的前后台一起的项目模板，没有找到还不错的，最近自己动手搞了个 </p><p><br></p><p>如果哪位大神有很好的模板欢迎推荐给在下</p><p><br></p><p>上地址 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/tiandao5d/kvxl.git\" rel=\"noopener noreferrer\" target=\"_blank\">https://link.zhihu.com/?target=https%3A//github.com/tiandao5d/kvxl.git</a></p>","type":"vue","createTime":1605161279573,"updateTime":1605851154795,"description":"很早以前整的，原先还妄称全栈，其实不过是个前后台代码放一起的简单模板"}]}