{"id":7,"items":[{"id":7,"title":"让 useReducer 可以使用惰性 state","icon":"","content":"<p>在使用useReducer 时，发现这个鬼记录的state没有惰性功能</p><p><br></p><p>如果我要记录的state的初始值需要经过大量计算得到，那就有点尴尬了</p><p><br></p><p>然后就想了个简单办法，借用useState的惰性功能</p><p><br></p><p>自定义hook代码如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\">function useXLReducer(_state) {\n  function reducer(state, action) {\n    // ... 一些操作\n    return { ...state};\n  }\n  // 这个是惰性的，如果_state是一个函数，会惰性执行\n  // 这个状态只会被第一次用到，也是保存了初始值\n  // 这样就可以让 useReducer 这个 hook 转为惰性的\n  // 支持传入的_state是一个函数\n  const [initState] = useState(_state);\n  const [state, dispatch] = useReducer(reducer, initState);\n\n\n  // 看个人喜好 可以将初始值 initState 保存下来\n  return [state, dispatch, initState];\n}\n</pre>","type":"javascript","createTime":1605162462429,"updateTime":0},{"id":6,"title":"有意思的useRef","icon":"","content":"<p>这样整一个hooks，玩的很有意思，单独拎出来发一个</p><p><br></p><p>这样配合使用 useState useState</p><pre class=\"ql-syntax\" spellcheck=\"false\">function useXulin(initData) {\n  let [up, setUp] = useState({});\n  let refObj = useRef(initData);\n  let state = refObj.current;\n  function update(obj) {\n    assign(obj);\n    setUp({});\n  }\n  function assign(obj) {\n    if (obj) {\n      refObj.current = Object.assign(refObj.current, obj);\n      state = refObj.current;\n    }\n  }\n  // state 状态数据\n  // update 组件更新\n  // assign 数据合并\n  return [state, update, assign];\n}\n</pre>","type":"javascript","createTime":1605162307810,"updateTime":0},{"id":5,"title":"更新数据时不更新组件","icon":"","content":"<p>有时候，我们只想更新某些数据，但并不想组件也更新，只有当组件下一次更新时才需要这些数据</p><p><br></p><p>比如鼠标移入移除时我们只需要记录状态，等待下一次更新时拿到这个状态然后：</p><pre class=\"ql-syntax\" spellcheck=\"false\">// 也可以用来阻止渲染\n// 有些时候我只想更新数据，不想更新组件\n\n\n// 这种方式一样适用于 vue 用以减少数据劫持问题\n// 无需冻结数据，或者转换数据\n// vue就不写了，可以自己玩玩\n\n\nfunction XLRef() {\n  let [up, setUp] = useState({}); // 更新组件的状态记录\n  let stateRef = useRef({ a: 1, b: 2 }); // 组件使用的状态数据\n  // let state = stateRef.current; // 如果觉着 stateRef.current.a 太长可以这样转换\n\n\n  // 状态数据更新，不是组件更新\n  function assign(obj?: any) {\n    if (obj) {\n      stateRef.current = Object.assign(stateRef.current, obj);\n      // 转换后，相应的覆盖重置\n      // state = stateRef.current;\n    }\n  }\n  // 更新数据后，更新组件，可以不传数据，只更新组件\n  function update(obj?: any) {\n    assign(obj);\n    setUp({});\n  }\n\n\n  // 三个按键的点击事件\n  function onClick1() {\n    // assign({ a: state.a + 1, b: state.b - 1 }); // 然后就可以这样用了\n    assign({ a: stateRef.current.a + 1, b: stateRef.current.b - 1 });\n  }\n\n\n  function onClick2() {\n    update();\n  }\n\n\n  function onClick3() {\n    // update({ a: state.a + 1, b: state.b - 1 }); // 然后就可以这样用了\n    update({ a: stateRef.current.a + 1, b: stateRef.current.b - 1 });\n  }\n  return (\n    &lt;div&gt;\n      {JSON.stringify(stateRef.current)}\n      &lt;button onClick={onClick1}&gt;数据更新，组件不更新&lt;/button&gt;\n      &lt;button onClick={onClick2}&gt;数据不更新，组件更新&lt;/button&gt;\n      &lt;button onClick={onClick3}&gt;都更新&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\n\n// 整成hook\n// typescript 不熟，不喜欢可以随意喷意见\ninterface ObjType {\n  [str: string]: any;\n}\nexport function useRefState(initData: ObjType): [ObjType, Function, Function] {\n  let [up, setUp] = useState({});\n  let refObj = useRef(initData);\n  let state = refObj.current;\n  function update(obj?: ObjType) {\n    assign(obj);\n    setUp({});\n  }\n  function assign(obj?: ObjType) {\n    if (obj) {\n      refObj.current = Object.assign(refObj.current, obj);\n      state = refObj.current;\n    }\n  }\n  // state 状态数据\n  // update 组件更新\n  // assign 数据合并\n  return [state, update, assign];\n}\n</pre>","type":"javascript","createTime":1605162097537,"updateTime":0},{"id":4,"title":"设计模式，职责链模式","icon":"","content":"<p>读 曾探 前辈的【JavaScript 设计模式与开发实践】一书，有感</p><pre class=\"ql-syntax\" spellcheck=\"false\">// 此处例子是书中源码\nvar order500 = function (orderType, pay, stock) {\n  if (orderType === 1 &amp;&amp; pay === true) {\n    console.log(\"500 元定金预购，得到 100 优惠券\");\n  } else {\n    return \"nextSuccessor\"; // 我不知道下一个节点是谁，反正把请求往后面传递\n  }\n};\nvar order200 = function (orderType, pay, stock) {\n  if (orderType === 2 &amp;&amp; pay === true) {\n    console.log(\"200 元定金预购，得到 50 优惠券\");\n  } else {\n    return \"nextSuccessor\"; // 我不知道下一个节点是谁，反正把请求往后面传递 }\n  }\n};\nvar orderNormal = function (orderType, pay, stock) {\n  if (stock &gt; 0) {\n    console.log(\"普通购买，无优惠券\");\n  } else {\n    console.log(\"手机库存不足\");\n  }\n};\nvar Chain = function (fn) {\n  this.fn = fn;\n  this.successor = null;\n};\nChain.prototype.setNextSuccessor = function (successor) {\n  return (this.successor = successor);\n};\nChain.prototype.passRequest = function () {\n  return ret;\n};\nvar ret = this.fn.apply(this, arguments);\nif (ret === \"nextSuccessor\") {\n  return (\n    this.successor &amp;&amp;\n    this.successor.passRequest.apply(this.successor, arguments)\n  );\n}\nvar chainOrder500 = new Chain(order500);\nvar chainOrder200 = new Chain(order200);\nvar chainOrderNormal = new Chain(orderNormal);\nchainOrder500.setNextSuccessor(chainOrder200);\nchainOrder200.setNextSuccessor(chainOrderNormal);\nchainOrder500.passRequest(1, true, 500); // 输出:500 元定金预购，得到 100 优惠券\nchainOrder500.passRequest(2, true, 500); // 输出:200 元定金预购，得到 50 优惠券\nchainOrder500.passRequest(3, true, 500); // 输出:普通购买，无优惠券\nchainOrder500.passRequest(1, false, 0); // 输出:手机库存不足\n\n\n// 此处为个人想法\n// 这种职责链模式也挺有意思的，可以任意改动执行顺序\nlet mode1 = [order500, order200, orderNormal];\nfunction render(mode, ...args) {\n  mode.some((fn) =&gt; {\n    if (fn.apply(null, args) !== \"nextSuccessor\") {\n      return true;\n    }\n  });\n}\nrender(mode1, 1, true, 500);\n</pre>","type":"javascript","createTime":1605162030858,"updateTime":0},{"id":3,"title":"重置组件的方法","icon":"","content":"<p>react 组件重置，所有的状态清空</p><p><br></p><p>组件重置，还原组件，react</p><p><br></p><p>利用虚拟DOM更新原理</p><pre class=\"ql-syntax\" spellcheck=\"false\">// 高阶组件，props 传入 _factor参数，参数改变时会重新渲染组件，不保存任何状态，相当于重置\nfunction resetCom(Com, val) {\n  return function (props) {\n    let [num, setNum] = useState(val);\n    if (!Object.is(props._factor, num)) {\n      Promise.resolve().then(() =&gt; {\n        setNum(props._factor);\n      });\n      return &lt;div&gt;&lt;/div&gt;;\n    }\n    return &lt;Com {...props} /&gt;;\n  };\n}\n\n\n// 使用\n\n\n// 包装需要重置的组件\nconst Box = resetCom(function () {\n  let [num, setNum] = useState(0);\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;这里是 App的子组件 , Box 组件&lt;/h3&gt;\n      &lt;p&gt;点击改变Box 的 状态数据&lt;/p&gt;\n      &lt;button onClick={() =&gt; setNum(num + 1)}&gt;Box {num}&lt;/button&gt;\n    &lt;/div&gt;\n  );\n});\n\n\n// 使用需要重置组件的组件\nfunction App() {\n  // 当数据改变时会重置Box组件，清除状态（重置组件）\n  let [num, setNum] = useState(0);\n  return (\n    &lt;div&gt;\n      &lt;h3&gt;这里是 App 组件&lt;/h3&gt;\n      &lt;p&gt;点击改变App状态数据，从而重置 Box组件的状态&lt;/p&gt;\n      &lt;button onClick={() =&gt; setNum(num + 1)}&gt;App {num}&lt;/button&gt;\n      &lt;p style={{ height: \"30px\" }}&gt;&lt;/p&gt;\n      &lt;Box _factor={num} /&gt;\n    &lt;/div&gt;\n  );\n}\n</pre>","type":"javascript","createTime":1605161963162,"updateTime":1605164455038},{"id":2,"title":"vue+koa2全栈框架模板","icon":"","content":"<p>找了好久的前后台一起的项目模板，没有找到还不错的，最近自己动手搞了个  </p><p><br></p><p>如果哪位大神有很好的模板欢迎推荐给在下</p><p><br></p><p>上地址 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/tiandao5d/kvxl.git\" rel=\"noopener noreferrer\" target=\"_blank\">https://link.zhihu.com/?target=https%3A//github.com/tiandao5d/kvxl.git</a></p>","type":"javascript","createTime":1605161279573,"updateTime":1605166518539}]}